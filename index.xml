<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hack Mongo</title>
    <link>http://hackmongo.com/</link>
    <description>Recent content on Hack Mongo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 20 Aug 2017 11:20:00 -0700</lastBuildDate>

	<atom:link href="http://hackmongo.com/index.xml" rel="self" type="application/rss+xml" />


    <item>
      <title>How To Test the Database</title>
      <link>http://hackmongo.com/post/how-to-test-the-database/</link>
      <pubDate>Sun, 20 Aug 2017 11:20:00 -0700</pubDate>

      <guid>http://hackmongo.com/post/how-to-test-the-database/</guid>
      <description>&amp;ldquo;How do I test the database?&amp;rdquo; is a question I&amp;rsquo;ve been asked by colleagues many times. There&amp;rsquo;s a good, clean solution, but let&amp;rsquo;s first step back from what seems to be the problem to unpack why &amp;ldquo;testing the database&amp;rdquo; is not special (but nonetheless important). In other words: colleagues don&amp;rsquo;t ask, &amp;ldquo;How do I test such-and-such package?&amp;rdquo;, because that&amp;rsquo;s common and well understood. The question about testing the database implies that the database is a special beast that, if not treated properly, will devour the developer in their sleep.</description>
    </item>

    <item>
      <title>Design Before Implementation</title>
      <link>http://hackmongo.com/post/design-before-implementation/</link>
      <pubDate>Tue, 01 Aug 2017 00:00:00 +0000</pubDate>

      <guid>http://hackmongo.com/post/design-before-implementation/</guid>
      <description>Like most software engineers, I review my colleagues&amp;rsquo; code. I rarely provide feedback on implementation details because developers rarely choose obviously bad implementations. I focus my attention on design rather than implementation for one simple reason: implementation details are easy to change when software is well designed. Or, from the business perspective, design is the most costly aspect of software to change, so I review for great and therefore cost-effective design.</description>
    </item>

    <item>
      <title>Reading os/exec.Cmd Output Without Race Conditions</title>
      <link>http://hackmongo.com/post/reading-os-exec-cmd-output-without-race-conditions/</link>
      <pubDate>Sat, 17 Jun 2017 00:00:00 +0000</pubDate>

      <guid>http://hackmongo.com/post/reading-os-exec-cmd-output-without-race-conditions/</guid>
      <description>Golang Weekly issue 164 features a nice article, Advanced command execution in Go with os/exec, which details several ways of working with os/exec, especially how to read STDOUT and STDERR while the command is running. This common task is commonly done wrong, where &amp;ldquo;wrong&amp;rdquo; means &amp;ldquo;the code has a race condition&amp;rdquo;. This blog post shows how to read STDOUT and STDERR from an os/exec.Cmd while it&amp;rsquo;s running and without race conditions.</description>
    </item>

    <item>
      <title>Custom MongoDB Replica Set Write Concern</title>
      <link>http://hackmongo.com/post/custom-mongodb-replica-set-write-concern/</link>
      <pubDate>Sun, 11 Jun 2017 00:00:00 +0000</pubDate>

      <guid>http://hackmongo.com/post/custom-mongodb-replica-set-write-concern/</guid>
      <description>One of the great things about MongoDB is write concern:
 Write concern describes the level of acknowledgement requested from MongoDB for write operations to a standalone mongod or to replica sets or to sharded clusters.
 Awesome! I want 1 write ack from any secondary in the primary DC so when the primary crashes we&amp;rsquo;re guaranteed to have an up-to-date secondary in the primary DC ready to be elected primary.</description>
    </item>

    <item>
      <title>Go Antipatterns</title>
      <link>http://hackmongo.com/page/golang-antipatterns/</link>
      <pubDate>Sat, 03 Jun 2017 18:51:14 -0700</pubDate>

      <guid>http://hackmongo.com/page/golang-antipatterns/</guid>
      <description>Go Antipatterns These Go lang antipatterns are inspired by SQL Antipatterns. Antipattern Go code is syntactically correct, but there&amp;rsquo;s a better way that&amp;rsquo;s both functionally equivalent and idiomatic.
These are guidelines not absolutes. For example, Generic Package is common in practice and often difficult to avoid. Spending significant time trying to rename a util package can quickly amount to bikeshedding. Therefore, an Importance is listed for each antipattern:
   Importance Guideline     low Easy to make better later, so it can wait   medium Becomes more difficult to change the longer it remains, so make it better as soon as possible   high Make it better right now because it reflects and effects deep technical choices that are difficult to change later    All examples are from real code but anonymized and simplified.</description>
    </item>

    <item>
      <title>Idiomatic Go</title>
      <link>http://hackmongo.com/page/idiomatic-go/</link>
      <pubDate>Sat, 03 Jun 2017 00:00:00 +0000</pubDate>

      <guid>http://hackmongo.com/page/idiomatic-go/</guid>
      <description> Idiomatic Go Canon can·on&amp;nbsp;&amp;nbsp;/ˈkanən/&amp;nbsp;&amp;nbsp;noun : a general law, rule, principle, or criterion by which something is judged
These texts explicitly and implicitly define idiomatic Go code. Read, memorize, and refer to them often. Use them to settle debates.
 Effective Go Golang FAQ Go at Google: Language Design in the Service of Software Engineering Go Standard Library Packages Godoc: documenting Go code Go Package Names  Recommended  Go Code Review Comments Best practices for a new Go developer Reducing Type Hierarchies  </description>
    </item>

    <item>
      <title>About</title>
      <link>http://hackmongo.com/page/about/</link>
      <pubDate>Mon, 29 May 2017 00:00:00 +0000</pubDate>

      <guid>http://hackmongo.com/page/about/</guid>
      <description>Hack Mongo Hack Mongo is my personal blog about databases, the Go programming language, and software design. The name is a reference to Hack MySQL, another site/blog I maintained for ten years (2005-2015) while building a career with MySQL. Today, the new frontier is MongoDB, hence the new name: Hack Mongo.
The content of this site is inspired by two things. First is my job: I work at Square as a DBA and Platform Engineer.</description>
    </item>

  </channel>
</rss>
